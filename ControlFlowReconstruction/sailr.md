# Ahoy SAILR!There is No Need to DREAM of C: A Compiler-Aware Structuring Algorithm for Binary Decompilation

## Summary

This paper presents a comprehensive study on the issue of **spurious gotos** in decompiled code, which are primarily caused by compiler-induced optimizations. The authors introduce a new approach called SAILR (Structuring After Intermediate Language Recovery) to address this problem.

The study begins with a quantitative analysis to identify the root causes of spurious gotos. The authors found that these are largely due to a wide array of optimizations leveraged by the compiler.
To tackle this issue, the authors propose SAILR, a novel approach that structures decompiled code after recovering an intermediate language. SAILR works by identifying and reversing the effects of compiler optimizations that cause spurious gotos. The approach involves two main steps: ISD (Identical Statement Duplication) and ISC (Identical Statement Condensing) optimizations.

ISD optimizations involve the duplication of subgraphs found in the original source Control Flow Graph (CFG). SAILR identifies these duplicates and condenses them. ISC optimizations, on the other hand, reduce subgraphs in the original source CFG through condensing. SAILR identifies these reductions and reverses them.

The effectiveness of SAILR was evaluated using a new metric that measures how close the decompiled code structure is to the original source code. The results showed that SAILR significantly improves on prior work. It performed well on binaries compiled with non-GCC compilers and was effective in handling simple binary-level control flow transfers such as jmp instructions.

In conclusion, the paper presents a significant step forward in the field of decompilation, offering a new approach to structuring decompiled code and reducing the presence of spurious gotos. The results suggest that SAILR is a promising solution to this long-standing problem.

## Ealuation

The evaluation of SAILR, the structuring algorithm proposed in this paper, was conducted using two sets of C binaries: popular Debian packages and MSVC compilable packages. The authors aimed to answer three research questions:

- How does SAILR perform on binaries compiled with older and newer GCC versions?
- How does SAILR perform on binaries compiled with non-GCC compilers?
- Given that SAILR is guided by findings on GCC 9.5, how does it perform on binaries generated by different C compilers?

The evaluation metrics used were Structuredness, which measures how often a structuring algorithm creates C structures in the output, and CFGED (Control Flow Graph Edit Distance), which measures the structural similarity between the decompiled code and the original source code.

The evaluation showed that SAILR significantly improved the structuring performance over other structuring algorithms and state-of-the-art decompilers. It performed well on binaries compiled with non-GCC compilers and was effective in handling simple binary-level control flow transfers such as jmp instructions.

In addition to the Debian packages, the authors also evaluated SAILR on a subset of the Linux kernel and a malware sample, the SpyEye malware on Windows. In both cases, SAILR outperformed other solutions in terms of relative goto emittance.

![eggWkrjv18](https://github.com/IAPCP/Decompiler-SoK/assets/11942934/b1991dc3-933a-4909-a6a4-e72cb9c50080)


https://www.zionbasque.com/files/publications/sailr_usenix24.pdf
